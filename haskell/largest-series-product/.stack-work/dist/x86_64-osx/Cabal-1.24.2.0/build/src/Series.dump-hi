
==================== FINAL INTERFACE ====================
2017-07-29 17:26:03.679846 UTC

interface largest-series-product-1.0.0.3-5WbGlQ8fXfwFLxdmpyEga4:Series 8002
  interface hash: 978f0c7ed6e020f6438c95dded651758
  ABI hash: 7f081c1aa0ad65a0ff8fc71387afeeed
  export-list hash: 75e1b0c4bcbaa324716d273b9b09abba
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Series.largestProduct
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
0e9de3426768235b55aded8df8a7cb77
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Series.$trModule2
                   Series.$trModule1) -}
e715de2428183f3491d96e79c308383a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Series"#) -}
e0098eceecf49087c2c6711e5d0c3e54
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "largest-series-product-1.0.0.3-5WbGlQ8fXfwFLxdmpyEga4"#) -}
fd3a0285fd56c7b08133bd690fd3b101
  $wgo ::
    [GHC.Integer.Type.Integer]
    -> GHC.Prim.Int#
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <S,1*U><L,1*U><S,1*U>, Inline: [0] -}
e25c2f9b80593f9ac824a5d739d246ee
  $wlargestProduct ::
    GHC.Prim.Int#
    -> GHC.Base.String -> GHC.Base.Maybe GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: GHC.Base.String) ->
                 case ww of wild {
                   DEFAULT
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# wild 0#) of wild1 {
                        GHC.Types.False
                        -> case GHC.List.$wlenAcc @ GHC.Types.Char w 0# of ww2 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># wild ww2) of wild2 {
                             GHC.Types.False
                             -> case (Series.largestProduct_go1 w)
                                       `cast`
                                     (Data.Monoid.N:Any[0]) of wild3 {
                                  GHC.Types.False
                                  -> GHC.Base.Just
                                       @ GHC.Integer.Type.Integer
                                       (let {
                                          lvl :: GHC.Types.Bool
                                          = GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.<# 0# wild)
                                        } in
                                        letrec {
                                          h :: [GHC.Integer.Type.Integer]
                                               -> GHC.Integer.Type.Integer
                                            {- Arity: 1, Strictness: <S,U> -}
                                          = \ (l :: [GHC.Integer.Type.Integer]) ->
                                            case GHC.List.$wlenAcc
                                                   @ GHC.Integer.Type.Integer
                                                   l
                                                   0# of ww1 { DEFAULT ->
                                            case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.==# wild ww1) of wild4 {
                                              GHC.Types.False
                                              -> let {
                                                   x :: GHC.Integer.Type.Integer
                                                   = case lvl of wild5 {
                                                       GHC.Types.False -> Series.largestProduct2
                                                       GHC.Types.True
                                                       -> Series.$wgo
                                                            l
                                                            wild
                                                            Series.largestProduct2 }
                                                 } in
                                                 let {
                                                   y :: GHC.Integer.Type.Integer
                                                   = h (Series.$wunsafeDrop
                                                          @ GHC.Integer.Type.Integer
                                                          1#
                                                          l)
                                                 } in
                                                 case GHC.Integer.Type.leInteger#
                                                        x
                                                        y of wild5 { DEFAULT ->
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        wild5 of wild6 {
                                                   GHC.Types.False -> x GHC.Types.True -> y } }
                                              GHC.Types.True
                                              -> Series.largestProduct_go
                                                   l
                                                   Series.largestProduct2 } }
                                        } in
                                        h (GHC.Base.map
                                             @ GHC.Types.Char
                                             @ GHC.Integer.Type.Integer
                                             Series.largestProduct3
                                             w))
                                  GHC.Types.True -> GHC.Base.Nothing @ GHC.Integer.Type.Integer }
                             GHC.Types.True -> GHC.Base.Nothing @ GHC.Integer.Type.Integer } }
                        GHC.Types.True -> GHC.Base.Nothing @ GHC.Integer.Type.Integer }
                   0# -> Series.largestProduct1 }) -}
b8a16fbb1a4b2f9b0dbe923a18a3bf28
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
06ba0f71783bc2debf7f286575212c3f
  largestProduct ::
    GHC.Types.Int
    -> GHC.Base.String -> GHC.Base.Maybe GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Series.$wlargestProduct ww1 w1 }) -}
55f4f5fbb8c3263a7976b87a0c12eb36
  largestProduct1 :: GHC.Base.Maybe GHC.Integer.Type.Integer
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ GHC.Integer.Type.Integer
                   Series.largestProduct2) -}
a0a17890eab07e65c63c2ca620b89956
  largestProduct2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
3163d95e1f51377d33ae2689767e84c3
  largestProduct3 :: GHC.Types.Char -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S(S),1*U(U)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Char) ->
                 case x of ww { GHC.Types.C# ww1 ->
                 case Data.Char.$wdigitToInt ww1 of ww2 { DEFAULT ->
                 GHC.Integer.Type.smallInteger ww2 } }) -}
792cae358d6870a4e4788feacf2de4d0
  largestProduct_go ::
    [GHC.Integer.Type.Integer]
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c79eb930e1ca5e02c0a988c00a2c6823
  largestProduct_go1 :: [GHC.Types.Char] -> Data.Monoid.Any
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False


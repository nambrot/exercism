
==================== FINAL INTERFACE ====================
2017-07-30 01:05:54.439018 UTC

interface pythagorean-triplet-0.1.0.2-691wZFDTujf96GsrNXq1YC:Triplet 8002
  interface hash: 17a7f8d2b98618ebda3602587fc2cda9
  ABI hash: dbc04b9630de2a8ff43d554bfbe618db
  export-list hash: 0838d166a8ae8d9f5f05423091ad2792
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f6624f22fcdd76ed0ac6625466e2d712
  sig of: Nothing
  used TH splices: False
  where
exports:
  Triplet.isPythagorean
  Triplet.mkTriplet
  Triplet.pythagoreanTriplets
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
c4961bfe154b93bed040f7143942ef7e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Triplet.$trModule2
                   Triplet.$trModule1) -}
3a0148a1e62b6669854062fd2bddc3de
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Triplet"#) -}
da2ee3987cdc3d7bd7e4e6687b93918d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "pythagorean-triplet-0.1.0.2-691wZFDTujf96GsrNXq1YC"#) -}
2b923ab47a775f23c6afaac6f011c480
  $wgo ::
    [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U>,
     Inline: [0] -}
bd71d359c4dd7142964512153ba2e191
  $wisPythagorean ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x :: GHC.Prim.Int#)[OneShot] ->
                     case Triplet.$wgo
                            (Data.OldList.sortBy
                               @ GHC.Types.Int
                               GHC.Classes.compareInt
                               (GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I# ww)
                                  (GHC.Types.:
                                     @ GHC.Types.Int
                                     (GHC.Types.I# ww1)
                                     (GHC.Types.:
                                        @ GHC.Types.Int
                                        (GHC.Types.I# ww2)
                                        (GHC.Types.[] @ GHC.Types.Int)))))
                            2#
                            0# of ww3 { DEFAULT ->
                     GHC.Prim.tagToEnum#
                       @ GHC.Types.Bool
                       (GHC.Prim.==# ww3 (GHC.Prim.*# x x)) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww ww1) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww ww2) of wild1 {
                        GHC.Types.False -> $j ww GHC.Types.True -> $j ww2 }
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww1 ww2) of wild1 {
                        GHC.Types.False -> $j ww1 GHC.Types.True -> $j ww2 } }) -}
484b5331e8593ab2bd9e43241d7c6ce5
  $wpythagoreanTriplets ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww ww1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go :: GHC.Prim.Int#
                              -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
                          {- Arity: 1, Strictness: <S,U> -}
                        = \ (x :: GHC.Prim.Int#) ->
                          let {
                            n :: [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
                            = case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x ww1) of wild1 {
                                GHC.Types.False -> go (GHC.Prim.+# x 1#)
                                GHC.Types.True
                                -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int) }
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x ww1) of wild1 {
                            GHC.Types.False
                            -> let {
                                 wild2 :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x
                               } in
                               letrec {
                                 go1 :: GHC.Prim.Int#
                                        -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
                                   {- Arity: 1, Strictness: <S,U> -}
                                 = \ (x1 :: GHC.Prim.Int#) ->
                                   let {
                                     n1 :: [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
                                     = case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# x1 ww1) of wild3 {
                                         GHC.Types.False -> go1 (GHC.Prim.+# x1 1#)
                                         GHC.Types.True -> n }
                                   } in
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.># x1 ww1) of wild3 {
                                     GHC.Types.False
                                     -> let {
                                          wild4 :: GHC.Types.Int {- Strictness: m -}
                                          = GHC.Types.I# x1
                                        } in
                                        letrec {
                                          go2 :: GHC.Prim.Int#
                                                 -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
                                            {- Arity: 1, Strictness: <L,U> -}
                                          = \ (x2 :: GHC.Prim.Int#) ->
                                            case Triplet.$wisPythagorean x x1 x2 of wild5 {
                                              GHC.Types.False
                                              -> case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.==# x2 ww1) of wild6 {
                                                   GHC.Types.False -> go2 (GHC.Prim.+# x2 1#)
                                                   GHC.Types.True -> n1 }
                                              GHC.Types.True
                                              -> GHC.Types.:
                                                   @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
                                                   (wild2, wild4, GHC.Types.I# x2)
                                                   (case GHC.Prim.tagToEnum#
                                                           @ GHC.Types.Bool
                                                           (GHC.Prim.==# x2 ww1) of wild6 {
                                                      GHC.Types.False -> go2 (GHC.Prim.+# x2 1#)
                                                      GHC.Types.True -> n1 }) }
                                        } in
                                        go2 x1
                                     GHC.Types.True -> n1 }
                               } in
                               go1 x
                            GHC.Types.True -> n }
                      } in
                      go ww
                   GHC.Types.True
                   -> GHC.Types.[]
                        @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int) }) -}
dd7931755edec820bc064c68f7dd0a1f
  isPythagorean ::
    (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)S(S)S(S)),1*U(1*U(U),1*U(U),U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Types.I# ww5 ->
                 case ww2 of ww6 { GHC.Types.I# ww7 ->
                 case ww3 of ww8 { GHC.Types.I# ww9 ->
                 Triplet.$wisPythagorean ww5 ww7 ww9 } } } }) -}
1297dd54aae2e797605637978d5fe836
  mkTriplet ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                (GHC.Tuple.(,,) @ GHC.Types.Int @ GHC.Types.Int @ GHC.Types.Int) -}
6221880ce73b43869db9534e025e37e9
  pythagoreanTriplets ::
    GHC.Types.Int
    -> GHC.Types.Int -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Triplet.$wpythagoreanTriplets ww1 ww3 } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

